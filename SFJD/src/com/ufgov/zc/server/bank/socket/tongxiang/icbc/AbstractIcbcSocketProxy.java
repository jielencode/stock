package com.ufgov.zc.server.bank.socket.tongxiang.icbc;import java.io.InputStream;import java.io.OutputStream;import java.util.Map;import org.dom4j.Document;import org.dom4j.DocumentException;import com.ufgov.zc.common.commonbiz.model.AutheInfo;import com.ufgov.zc.common.system.constants.SocketConstants;import com.ufgov.zc.common.system.exception.MessageStructureException;import com.ufgov.zc.common.system.model.ResultInfo;import com.ufgov.zc.common.system.util.XmlUtils;import com.ufgov.zc.server.bank.socket.tongxiang.TransactionSocketProxy;/** * 与工行进行支付交易的socket * @author liubo * */public abstract class AbstractIcbcSocketProxy extends TransactionSocketProxy {  private AutheInfo autheInfo;  public AutheInfo getAutheInfo() {    return autheInfo;  }  public void setAutheInfo(AutheInfo autheInfo) {    this.autheInfo = autheInfo;  }  public AbstractIcbcSocketProxy() {    super();  }  public AbstractIcbcSocketProxy(Map prop) {    super(prop);  }  /**   * 发送用户信息，从工行服务中取得随机数   */  public String handleSendMessage(Object businessObject, OutputStream output) throws Exception {    String message = parseToXml(businessObject);    String resultStr = "0000000000";    resultStr += message.length() + 7;    resultStr = resultStr.substring(resultStr.length() - 10);    resultStr += message + "ICBCCMP";    //Integer buffersize = (Integer) this.getSocketProp().get(SocketConstants.SEND_BUFFER_SIZE);    //buffersize = buffersize == null ? new Integer(1024) : buffersize;    //工行全包发送    String charset = (String) this.getProperty("charset");    charset = charset == null ? "gb2312" : charset;    Integer buffersize = new Integer(resultStr.getBytes(charset).length);    this.sendMessageInfo(resultStr, buffersize.intValue(), output);    return resultStr;  }  public ResultInfo handleReceiveMessage(Object businessObject, InputStream input) throws Exception {    ResultInfo result = new ResultInfo();    try {      Integer buffersize = (Integer) this.getSocketProp().get(SocketConstants.RECE_BUFFER_SIZE);      buffersize = buffersize == null ? new Integer(1024) : buffersize;      String message = this.receiveMessageInfo(input, buffersize);      result.setOriginalMessage(message);      Document doc = XmlUtils.parse(message);      String returnCode = XmlUtils.evaluate("//MESSAGE/RETURNCODE", doc);      String returnMess = XmlUtils.evaluate("//MESSAGE/RETURNMSG", doc);      String tradeFlag = XmlUtils.evaluate("//MESSAGE/MESSINFO/TRADEFLAG", doc);      String desc = XmlUtils.evaluate("//MESSAGE/MESSINFO/DESC", doc);      if (SocketConstants.SUCCESS.equals(returnCode)) {        result.setResultCode(SocketConstants.SUCCESS);        result.setTradeFlag(tradeFlag);        result.setDesc(desc);      } else if (SocketConstants.FAILURE.equals(returnCode)) {        result.setResultCode(SocketConstants.FAILURE);      }      result.setResultMessage(returnMess);      return result;    } catch (DocumentException ex) {      throw new MessageStructureException(ex.getMessage(), ex);    }  }  public void checkAutheInfo() {    AutheInfo autheInfo = this.getAutheInfo();    if (autheInfo.getUserInfo() == null) {      throw new IllegalArgumentException("认证信息中userInfo为空!");    } else if (autheInfo.getDataTmp() == null) {      throw new IllegalArgumentException("认证信息中随机数为空!");    } else if (autheInfo.getDateTime() == null) {      throw new IllegalArgumentException("认证信息中系统时间为空");    } else if (autheInfo.getCerInfo() == null) {      throw new IllegalArgumentException("认证信息中证书信息为空");    } else if (autheInfo.getPublicKey() == null) {      throw new IllegalArgumentException("认证信息中公钥为空");    } else if (autheInfo.getKeyInfo() == null) {      throw new IllegalArgumentException("认证信息中发证机构签名信息为空");    }  }  public abstract String parseToXml(Object businessObject) throws Exception;}