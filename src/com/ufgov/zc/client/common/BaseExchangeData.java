package com.ufgov.zc.client.common;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import com.ufgov.zc.common.system.RequestMeta;import com.ufgov.zc.common.system.dto.ElementConditionDto;import com.ufgov.zc.common.zc.model.DataExchange;import com.ufgov.zc.common.zc.model.DataExchangeRedo;import com.ufgov.zc.common.zc.publish.IDataExchangeServiceDelegate;/** * 查询ZC_DATA_EXCHANGE表，将所有部件和相关的主表、子表查询出来，并组织好其中的关系, * 为了简化其层次结构，全采用map来进行存储，考虑到多级子表的问题，故在存储子表时，将 * key值按一定的规则进行命名，对于子表，规则就是拼接一个父表名作为前缀。 * @author LEO */public class BaseExchangeData {  private static Map<String, DataExchange> existDataTypeMap = new HashMap<String, DataExchange>();  private static Map<String, List<DataExchangeRedo>> exportableDataExchangeRedoMap = new HashMap<String, List<DataExchangeRedo>>();  private static List<DataExchange> dbData = null;  private static List<DataExchangeRedo> redoData = null;  /**   * 抓取基础配置数据   */  public static void init(ElementConditionDto dto) {    exportableDataExchangeRedoMap.clear();    existDataTypeMap.clear();    RequestMeta meta = WorkEnv.getInstance().getRequestMeta();    IDataExchangeServiceDelegate dataExchangeServiceDelegate = (IDataExchangeServiceDelegate) ServiceFactory.create(    IDataExchangeServiceDelegate.class, "dataExchangeServiceDelegate");    dbData = dataExchangeServiceDelegate.getAllDataExchange(null, meta);    if (dto.getEndDate() != null) {      dto.setEndDate(new Date(dto.getEndDate().getTime() + 1000 * 3600 * 24 - 1000));    }    if (dto.getStatus() != null && "IN_OUT".indexOf(dto.getStatus()) >= 0) {      return;    }    redoData = dataExchangeServiceDelegate.getDataExchangeRedoList(dto, meta);    loadListDataToMap();  }  /**   * 将表结构整理出来   */  private static void loadListDataToMap() {    for (int i = 0; i < dbData.size() && i >= 0; i++) {      DataExchange de = dbData.get(i);      existDataTypeMap.put(de.getDataTypeID(), de);    }    String key = null;    List<DataExchangeRedo> redoList = null;    Iterator<String> it = existDataTypeMap.keySet().iterator();    while (it.hasNext()) {      redoList = new ArrayList<DataExchangeRedo>();      key = it.next();      for (int i = 0; i < redoData.size(); i++) {        DataExchangeRedo redo = redoData.get(i);        if (key.equals(redo.getDataTypeID())) {          redoList.add(redo);        }      }      exportableDataExchangeRedoMap.put(key, redoList);    }  }  public static Map<String, DataExchange> getExistDataTypeMap() {    return existDataTypeMap;  }  public static void setExistDataTypeMap(Map<String, DataExchange> existDataTypeMap) {    BaseExchangeData.existDataTypeMap = existDataTypeMap;  }  public static Map<String, List<DataExchangeRedo>> getExportableDataExchangeRedoMap() {    return exportableDataExchangeRedoMap;  }}