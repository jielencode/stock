package com.ufgov.zc.server.bank.socket.tongxiang.ccb;import java.io.InputStream;import java.io.OutputStream;import java.util.Map;import org.dom4j.Document;import org.dom4j.DocumentException;import com.ufgov.zc.common.system.constants.SocketConstants;import com.ufgov.zc.common.system.exception.AutheException;import com.ufgov.zc.common.system.exception.MessageStructureException;import com.ufgov.zc.common.system.model.ResultInfo;import com.ufgov.zc.common.system.util.XmlUtils;import com.ufgov.zc.server.bank.socket.tongxiang.TransactionSocketProxy;import com.ufgov.zc.server.cp.service.ICpVoucherService;import com.ufgov.zc.server.system.SpringContext;/** * 与建行进行支付交易的socket * @author liubo * */public abstract class AbstractCcbSocketProxy extends TransactionSocketProxy {  /**   * 建行客户端服务的配置文件地址,配置在as_option中以OPT_TX_CCB_CONFIG_PATH为OPTION_ID   */  //  private static String CONFIG_FILE_PATH = "";//"C:/Program Files/wlpt_app/conf/config.xml";  //  static {  //    IAsOptionService baseService = (IAsOptionService)SpringContext.getBean("asOptionService");  //    AsOption option = baseService.getAsOption("OPT_TX_CCB_CONFIG_PATH");  //    CONFIG_FILE_PATH = option.getOptVal();  //    if (CONFIG_FILE_PATH == null || CONFIG_FILE_PATH.length() == 0) {  //      CONFIG_FILE_PATH = "C:/Program Files/wlpt_app/conf/config.xml";  //    }  //  }  private ICpVoucherService voucherService = (ICpVoucherService) SpringContext.getBean("cpVoucherService");  private String requestSn;  public String getRequestSn() {    return requestSn;  }  public void setRequestSn(String requestSn) {    this.requestSn = requestSn;  }  public AbstractCcbSocketProxy() {    super();  }  public AbstractCcbSocketProxy(Map prop) {    super(prop);  }  public void beforeDealBusinessObject(Object businessObject) throws Exception {    try {      String custId = this.getAutheInfo().getUserId();      String operId = this.getAutheInfo().getOperId();      if (custId == null || operId == null) {        throw new Exception("建行配置文件中的用户号或操作号为空!");      }      //赋查询流水号      this.setRequestSn(voucherService.getRequestSeri().toString());    } catch (Exception ex) {      throw new AutheException(ex.getMessage(), ex);    }  }  public ResultInfo handleReceiveMessage(Object businessObject, InputStream input) throws Exception {    ResultInfo result = new ResultInfo();    try {      Integer buffersize = (Integer) this.getSocketProp().get(SocketConstants.RECE_BUFFER_SIZE);      buffersize = buffersize == null ? new Integer(1024) : buffersize;      String message = this.receiveMessageInfo(input, buffersize);      result.setOriginalMessage(message);      Document doc = XmlUtils.parse(message);      String returnCode = XmlUtils.evaluate("//TX/RETURN_CODE", doc);      returnCode = returnCode.trim();      String returnMess = XmlUtils.evaluate("//TX/RETURN_MSG", doc);      //交易标志位(在returnCode为000000时才有意义):1成功，2不成功，3无法查询是否成功,要请重新查询或人工查询      String tradeFloagMess = XmlUtils.evaluate("//TX/TX_INFO/TRADEFLAG", doc);      String desc = XmlUtils.evaluate("//TX/TX_INFO/DESC", doc);      String requestSn = XmlUtils.evaluate("//TX/REQUEST_SN", doc);      requestSn = requestSn.trim();      tradeFloagMess = tradeFloagMess.trim();      if (SocketConstants.SUCCESS.equals(returnCode)) {        if (this.getRequestSn().equals(requestSn)) {          result.setResultCode(SocketConstants.SUCCESS);          result.setTradeFlag(tradeFloagMess);          result.setDesc(desc);        } else {          //发送和返回的流水号不一致，视为 不确定，需要进行查询          result.setResultCode(SocketConstants.UNCERTAINTY);          result.setResultMessage("请求序列码不一致");        }      } else if (SocketConstants.FAILURE.equals(returnCode)) {        result.setResultCode(SocketConstants.FAILURE);      } else if (SocketConstants.UNCERTAINTY.equals(returnCode)) {        result.setResultCode(SocketConstants.UNCERTAINTY);      } else {        result.setResultCode(SocketConstants.UNCERTAINTY);      }      result.setResultMessage(returnMess);      return result;    } catch (DocumentException ex) {      throw new MessageStructureException(ex.getMessage(), ex);    }  }  public String handleSendMessage(Object businessObject, OutputStream output) throws Exception {    String message = parseToXml(businessObject);    Integer buffersize = (Integer) this.getSocketProp().get(SocketConstants.SEND_BUFFER_SIZE);    buffersize = buffersize == null ? new Integer(1024) : buffersize;    this.sendMessageInfo(message, buffersize.intValue(), output);    return message;  }  public abstract String parseToXml(Object businessObject) throws Exception;}